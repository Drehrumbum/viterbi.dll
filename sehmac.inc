comment!#######################################################################
#                           This file is part of                              #
#           'viterbi.dll replacement for QIRX-SDR (Windows 64 Bit)'           #
#                                                                             #
#  sehmac.inc                                                                 #
#                                                                             #
#  Two macros for generating 64-bit prologue/ epilogue code with Microsoft’s  #
#  macro assembler. The MASM is used here so that the VS-project runs 'out of #
#  the box' without having to install other assemblers first. The macros are  #
#  ONLY intended to make life a little bit easier when the assembler code     #
#  generated by the compiler is used for further development. If an exception #
#  occures inside of the assembly-language parts, which is unlikely, the      #
#  stack unwinds correctly and the caller can catch the exception as usual    #
#  with a try/except block somewhere in its code.                             #
#                                                                             #
#  Inspired by the two macro-examples of the same name in the MASM 6.1 user   #
#  manual from the early nineties of the last century.                        #
#                                                                             #
# 'NV' means 'non volatile'.                                                  #
#                                                                             #
#  2024-04-01: Calling __chkstk() if locals > 0x1000                          #
#                                                                             #
# (c) 2022/24 Heiko Vogel <hevog@gmx.de>                                      #
##############################################################################!

;; DS prefix-opcode for alignment-purposes.
dspre textequ <db 3eh>

extrn   __chkstk : PROTO


;; init some globals
ShadowSpace = 20h    ;; If not changed in front of a procedure, 'SaveRegs'
                     ;; reserves 32 bytes shadow space, so rsp is prepared
                     ;; after the prologue and you can call other (API-)
                     ;; functions with a maximum of four arguments w/o moving
                     ;; rsp inside of your proc. To keep it simple and the
                     ;; stack aligned, increase the value in 16 byte steps, if
                     ;; you need more shadow space for calls. You can set it to
                     ;; zero, if you don't call other functions. And yes, you
                     ;; can use this value for 'locals' too, but have to manage
                     ;; the whole stuff by yourself, of course.
                     ;;
LocalSpace = 0       ;; The size of locals in bytes. You have to manage the whole
                     ;; stuff by yourself. Your 'LocalSpace' starts at [rsp], not
                     ;; at [rsp + ShadowSpace].
                     ;;
UseVex = 0           ;; If set, the macros emit 'vmovdqa' instead of 'movdqa'.
                     ;;
NumLongOps = 0       ;; For alignment purposes you can increase the code-size
                     ;; of the prologue up to 10 bytes, if all NV-XMM regs are
                     ;; used. The SaveRegs macro emits 'movdqa' instructions
                     ;; instead of 'movaps' for the number given, because this
                     ;; instruction is one byte longer. If 'UseVex' is set, the
                     ;; DS override prefix is used in front of each 'vmovdqa'
                     ;; instruction.
                     ;;
WantHotPatch = 0     ;; If set, the SaveRegs macro emits a prefix byte to
                     ;; make the first push-instruction at function entry two
                     ;; bytes long. Use it or not - see below.


SaveRegs macro regs:vararg
local reg, XmmInside, StackAlignment, SaveSpaceAddr, Displacement
local NumGPR, NumXMM, NumLOP, Prefix
GPRPushed equ <>     ;; clear global list of NV-GPRs
XMMSaved equ <>      ;; clear global list of NV-XMM-regs
StackMovement = 0    ;; the amount of bytes we have to subtract from rsp
                     ;; after all NV-GPRs are pushed on stack to make room
                     ;; for the NV-XMM-regs, the locals and the shadow-space.
Prefix = 0           ;; init the counters
NumGPR = 0
NumXMM = 0
NumLOP = 0           ;; Number of long op-codes

    if NumLongOps gt 0
        NumLOP = NumLongOps
    endif

;; seperate and count the given NV-registers
    for reg, <regs>
        XmmInside INSTR <reg>, <xmm> ;; lowercase letters for register naming 

        if XmmInside ne 0
            XMMSaved CATSTR <reg>, <,>, XMMSaved
            NumXMM = NumXMM + 1
        else
;; Check, if one of the registers rbx, rbp, rdi or rsi (they have a one-byte
;; opcode for 'push') is the first NV-GPR in the register-list. In this case a
;; prefix byte (48h) will be emitted once. See '/hotpatch' MSVC-compiler flag
;; at MSDN or the file 'macamd64.inc' somewhere inside of your VS-installation
;; for more information. The clang compiler emits such a prefix-byte only on
;; request.

            if ((WantHotPatch ne 0) and (NumGPR eq 0))
                prefix instr <rbx rbp rsi rdi>, <reg>
                if prefix gt 0
                    db 48h
                endif
            endif
            push reg
            .pushreg reg
            GPRpushed TEXTEQU @CatStr (<reg>,<,>, %GPRpushed)
            NumGPR = NumGPR + 1 
        endif
    endm
    
    ifnb GPRpushed
        GPRpushed SUBSTR GPRpushed, 1, @SizeStr(%GPRpushed) - 1
        GPRpushed CATSTR <!<>, GPRpushed, <!>>
    endif

    ifnb XMMSaved
        XMMSaved  SUBSTR XMMSaved, 1, @SizeStr(%XMMSaved) - 1
        XMMSaved  CATSTR <!<>, XMMSaved, <!>>
    endif


;; The callee's stack looks something like this ('o' = optional)
;; --------------------------------------------------------------------
;; * callee's free shadow-space with a size of at least 32 bytes
;; * return-address; rsp points to an address which ends with 0x8
;; o maybe pushed NV-GPRs
;; o stack-alignment if the mumber of pushed NV-GPRs is zero or even,
;;   except in the case of a leaf function
;; o maybe saved NV-XMM and/or locals
;; o maybe reserved shadow-space for calls
;; * new rsp aligned at 16 bytes, except in the case of a leaf function

;; check, if stack-alignment is necessary
    StackAlignment = (1 - (NumGPR mod 2)) * 8 ;; returns 0 or 8

;; putting the pieces together and finally do the leaf-function check...
    if ((ShadowSpace eq 0) and (LocalSpace eq 0) and (NumGPR eq 0) and \
        (NumXMM eq 0))
        StackMovement = 0
    else
        StackMovement = StackAlignment + NumXMM * 16 + LocalSpace + ShadowSpace
        if StackMovement ne 0
            if StackMovement gt 01000h
                mov eax, StackMovement
                call __chkstk
                sub rsp, rax
            else
                sub rsp, StackMovement
            endif
            .allocstack StackMovement
        endif
    endif

;; Some free 'Save*' variables of different type in the callee's
;; 'always there' shadow-space. Only valid BETWEEN 'SaveRegs' and
;; 'RestoreRegs' AND IF the value of rsp is the same like right
;; after the 'SaveRegs' macro. It's a UNION, of course.

    SaveSpaceAddr = StackMovement + 8 + 8 * NumGPR

SaveXMM0 textequ @CatStr (<xmmword ptr [rsp + >, %SaveSpaceAddr, <]>)
Save_RCX textequ @CatStr (<qword ptr   [rsp + >, %SaveSpaceAddr, <]>)
SaveInt0 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr, <]>)
SaveInt1 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr + 4, <]>)
Save_RDX textequ @CatStr (<qword ptr   [rsp + >, %SaveSpaceAddr + 8, <]>)
SaveInt2 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr + 8, <]>)
SaveInt3 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr + 12, <]>)
SaveXMM1 textequ @CatStr (<xmmword ptr [rsp + >, %SaveSpaceAddr + 16, <]>)
Save__R8 textequ @CatStr (<qword ptr   [rsp + >, %SaveSpaceAddr + 16, <]>)
SaveInt4 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr + 16, <]>)
SaveInt5 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr + 20, <]>)
Save__R9 textequ @CatStr (<qword ptr   [rsp + >, %SaveSpaceAddr + 24, <]>)
SaveInt6 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr + 24, <]>)
SaveInt7 textequ @CatStr (<dword ptr   [rsp + >, %SaveSpaceAddr + 28, <]>)


Displacement = ShadowSpace + LocalSpace

ifnb XMMSaved
    if UseVex eq 0
        %for reg, XMMSaved
            if NumLOP gt 0
                movdqa xmmword ptr [rsp + Displacement], reg
                .savexmm128 reg, Displacement
                Displacement = Displacement + 16
                NumLOP = NumLOP - 1
            else
                movaps xmmword ptr [rsp + Displacement], reg
                .savexmm128 reg, Displacement
                Displacement = Displacement + 16
            endif
        endm
    else
        %for reg, XMMSaved
            if NumLOP gt 0
                dspre ;; DS override prefix
                vmovdqa xmmword ptr [rsp + Displacement], reg
                .savexmm128 reg, Displacement
                Displacement = Displacement + 16
                NumLOP = NumLOP - 1
            else
                vmovdqa xmmword ptr [rsp + Displacement], reg
                .savexmm128 reg, Displacement
                Displacement = Displacement + 16
            endif
        endm
    endif
endif
    .endprolog
endm

;; RestoreRegs - Macro
;; Save* variables are now invalid!
RestoreRegs macro 
local reg, Displacement
Displacement = ShadowSpace + LocalSpace

     ifnb XMMSaved
        if UseVex eq 0
            %for reg, XMMSaved
                movaps  reg, xmmword ptr [rsp + Displacement]
                Displacement = Displacement + 16
            endm
        else
            %for reg, XMMSaved    
                vmovaps  reg, xmmword ptr [rsp + Displacement]
                Displacement = Displacement + 16
            endm
        endif
    endif

    if StackMovement ne 0
        add rsp, StackMovement
    endif    

    ifnb GPRpushed       
        %for reg, GPRpushed
            pop reg
        endm
    endif
endm